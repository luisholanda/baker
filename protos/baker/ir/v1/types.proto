syntax = "proto3";

package baker.ir.v1;

import "baker/ir/v1/statement.proto";
import "baker/ir/v1/values.proto";

// A type instance in the IR.
message Type {
  // Fundamental types of the language.
  //
  // These commonly have special type syntax in concrete languages.
  enum Fundamental {
    // Not set.
    UNKNOWN = 0;
    // A tuple type.
    TUPLE = 1;
    // A vector type.
    VEC = 2;
    // A map type.
    MAP = 3;
    // A shared reference type.
    SHRD_REF = 4;
    // A unique reference type.
    UNIQ_REF = 5;
    // A constant pointer type.
    CONST_PTR = 6;
    // A common pointer type.
    PTR = 7;
    // Double point precision.
    DOUBLE = 8;
    // Single point precision.
    FLOAT = 9;
    // Signed int.
    S_INT = 10;
    // Signed long.
    S_LONG = 11;
    // Unsigned int.
    U_INT = 12;
    // Unsigned long.
    U_LONG = 13;
    // Bool.
    BOOL = 14;
    // String.
    STRING = 15;
    // Bytes.
    BYTES = 16;
    // Optional types.
    OPTIONAL = 17;
  }

  // Name of the type. Should not be set if `fundamental` is set.
  //
  // To keep consistency between all layers, this field MUST _always_ be in
  // `PascalCase`, even if it is a function declaration. Final code generators are
  // responsible for converting the case to the appropriate case in their respective
  // concrete languages.
  string name = 1;

  // The instance refers to a fundamental type.
  Fundamental fundamental = 2;

  // Any generic parameters associated with this type.
  repeated Type generics = 3;

  // All lifetime parameters with this type.
  repeated string lifetimes = 10;
}

// A type definition in the IR.
message TypeDef {
  // Record type definition.
  message Record {
    // A property inside a record.
    message Property {
      // The type of the property.
      Type type = 1;

      // The visibility of the property.
      Visibility visibility = 2;

      // All attributes of the property.
      //
      // What this field means depends on the generated language, e.g.:
      //   - In Rust, these should be added as attributes;
      //   - In Python, Java, or JavaScript, these should be added as decorators;
      //   - In Go, these can be added as metadata.
      repeated Attribute attributes = 3;

      // Documentation of this property.
      string documentation = 4;
    }

    // All properties in the record.
    map<string, Property> properties = 1;
  }

  // A sum type definition.
  message Sum {
    // A member of a sum type.
    message Member {
      // The value of the member.
      oneof value {
        // A C-like value.
        int32 fixed = 1;
        // A record value.
        TypeDef.Record record = 2;
        // A type reference.
        Type type = 3;
      };

      // Attributes of this member.
      repeated Attribute attributes = 5;

      // Documentation of this member.
      string documentation = 6;
    }

    // Members of the sum type.
    map<string, Member> members = 1;
  }

  // A set of implementations for a type.
  //
  // This can be used to add methods to it, or to add an interface
  // implementation.
  message ImplBlock {
    // The interface implemented by this block.
    optional Type interface = 1;

    // All methods defined in this block.
    repeated Function methods = 2;

    // All associated types needed for an interface implementation.
    //
    // This should not be set if `inferface` isn't set.
    repeated TypeAlias assoc_types = 3;

    // TODO(impls): handle constants.
  }

  // The type header.
  Type header = 1;

  // The type definition itself.
  oneof definition {
    // The type is a record (e.g. struct, data, class, etc.).
    Record record = 2;

    // The type is a sum type (C-like enums, Haskell-like enums, etc.).
    Sum sum = 3;
  };

  // All attributes in the type definition.
  repeated Attribute attributes = 5;

  // All implementation blocks for this type.
  repeated ImplBlock blocks = 6;

  // Documentation of the type.
  string documentation = 7;

  // Visibility of the type.
  Visibility visibility = 8;
}

// A type alias.
message TypeAlias {
  // The alias type.
  Type alias = 1;

  // The aliased type.
  Type aliased = 2;

  // The alias visibility.
  Visibility visibility = 4;

  // The alias documentation.
  string documentation = 5;
}

// A function definition.
message Function {
  // Argument of a function.
  message Argument {
    // Argument type.
    enum ArgType {
      // The argument is positional.
      POSITIONAL = 0;
    }

    // Name of the argument.
    string name = 1;
    // Argument type.
    ArgType arg_type = 2;
    // Type of the argument.
    Type type = 3;
  }

  // The function header.
  Type header = 1;

  // The return type.
  Type return = 2;

  // Function visibility.
  Visibility visibility = 3;

  // Function implementation.
  Block implementation = 4;

  // The receiver of the method.
  //
  // If not set, this is a static function.
  optional Type receiver = 5;

  // Function documentation.
  string documentation = 6;

  // Arguments of the function.
  repeated Argument arguments = 7;

  // Attributes in this function.
  repeated Attribute attributes = 8;

  // Is this function an async function?
  bool asyncness = 9;
}

// An interface definition.
message Interface {
  // Bounds added to a type.
  message Bounds {
    // Interfaces in the bound.
    repeated Type interfaces = 2;
    // Lifetimes in the bound.
    repeated string lifetimes = 3;
  }

  // An associated type in this interface.
  message AssocType {
    // The header of the assoc. type.
    Type header = 1;
    // Bounds in this assoc. type.
    optional Bounds bounds = 2;
  }

  // Interface header.
  Type header = 1;

  // Methods in the interface.
  repeated Function methods = 2;

  // Associated types in this interface.
  repeated AssocType assoc_types = 3;

  // Interface documentation.
  string documentation = 4;

  // TODO(impls): handle constants
}

// An attribute added to some item in the code.
message Attribute {
  // Value of the attribute.
  oneof value {
    // A function call attribute.
    //
    // E.g. `#[serde(rename_all = "camelCase")]`.
    FunctionCall call = 1;
    // An assignment attribute.
    //
    // E.g. `#[table_name = "foo"]`
    Statement.Assignment assignment = 2;
    // An identifier attribute.
    //
    // E.g. `#[tracing::instrument]`.
    string identifier = 3;
  };
}

// Possible visibility levels.
enum Visibility {
  UNKNOWN = 0;
  PRIVATE = 1;
  PROTECTED = 2;
  PACKAGE = 3;
  PUBLIC = 4;
}
